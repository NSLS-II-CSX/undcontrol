#####
# Need input .cvs file with energy, gap.  Will not work with column headers
# Use doc string of set_table() to check/test table before uploading
# Epics table generated by interpolation, but one could add an equation to autogenerate or develop a fit function.
# Upper and lower bounds currently set by input.  Can add another parameter and enable extrapolation for the interpolation function
#
# 09/13/17


import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import csv

def test_table(Emeas,Gmeas,Earraysize, Garraysize,minE, maxE, minG, maxG):
    '''
    This function requires that you hard code your fit to the gap vs energy data.  energy is the x-variable for the forward calculation.
    This function also requires a hard code fit for the reverse interpolation.  gap is the x-varyable.
    '''
    #print(file)
    print('Input energy min and max are:\t', np.min(Emeas),np.max(Emeas))
    print('Input gap min and max are:\t', np.min(Gmeas),np.max(Gmeas))
    
    
    Esp = (np.max(Emeas)-np.min(Emeas))/Earraysize
    Gsp = (np.max(Gmeas)-np.min(Gmeas))/Earraysize
    print('\nForward interpolation has energy and gap spacing of {:.3f} and {:.4f}'.format(Esp,Gsp))
    
    x = np.linspace(minE, maxE, Earraysize)
    y = np.interp(x, Emeas, Gmeas)
    
    
    
    plt.figure(figsize=(7,7))
    plt.plot(Emeas, Gmeas, 'o', label='input data ')#{}'.format(file))
    plt.plot(x,y,'--r', label='np.interp forward')
    plt.grid(True)
    plt.legend(loc=2)
    plt.show()
    
    
    x2 = np.linspace(minG, maxG, Garraysize)
    y2 = np.interp(x2, Gmeas, Emeas)

    Esp = (np.max(Emeas)-np.min(Emeas))/Garraysize
    Gsp = (np.max(Gmeas)-np.min(Gmeas))/Garraysize
    print('\nReverse interpolation has energy and gap spacing of {:.3f} and {:.4f}'.format(Esp,Gsp))
    
    plt.figure(figsize=(7,7))
    
    plt.plot(Gmeas,Emeas, 'o', label='input data ')#{}'.format(file))
    plt.plot(x2,y2,'--r', label='np.interp reverse')
    plt.grid(True)
    plt.legend(loc=2)
    plt.show()

    return x, y, x2, y2

def make_table(output,IOCtable):
    x=output[0]
    y=output[1]
    x2=output[1]#output[2]  ##2 and 3 are from previous version that needed to reverse interpolation
    y2=output[0]#output[3]
    
    #print('hello')
    
    #pv_stringi = ('XF:02ID-ID{EPU:1-RLT}Val:Table%sa-Wfrm'%(IOCtable))
    #print(pv_string)        
    
    #del pv  ### SAFEGUARD IF TESTING and pv is in namespace
    fp = np.concatenate((np.array([x[0], x[1] - x[0], y.size, -1, 1, 3]), y, y, y))
    ######pv = epics.PV('XF:02ID-ID{EPU:1-FLT}Val:Table1a-Wfrm')  ## example to test
    pv = epics.PV('XF:02ID-IDi{EPU:1-FLT}Val:Table%sa-Wfrm'%(IOCtable))
    print(f'Writing to PV:\t{pv}\n{fp}')
    pv.put(fp)
    
    fp = np.concatenate((np.array([x2[0], x2[1] - x2[0], y2.size, -1, 1, 3]), y2, y2, y2))
    ######pv = epics.PV('XF:02ID-ID{EPU:1-RLT}Val:Table1a-Wfrm')  ## example to test
    pv = epics.PV('XF:02ID-ID{EPU:1-RLT}Val:Table%sa-Wfrm'%(IOCtable))
    print(f'Writing to PV:\t{pv}\n{fp}')
    pv.put(fp)

    

def load_input(file):
    print('Input file is:\t', file,'\n\n')
    with open(file) as csvfile:
        readCSV = csv.reader(csvfile, delimiter='\t')
        xe = []
        yg = []

        try:
            for row in readCSV:
                #print(row)  #use just this line to figure out the delimiter  delete csv text in first line if not a number
                en = float(row[1])
                gp = float(row[2])

                xe.append(en)
                yg.append(gp)
        except ValueError as ex:
            print('\n\n**********\nError in extracting data from CSV.  Possibly due to header.  Remove non-numeric data.\n**********\n\n')
            raise
        return xe, yg


def set_EPU_table(file,pts = [1000,1000], params = None, IOCtable=1, final=False):
    '''
    pts is the number points for energy, gap:
        [0]\t output energy array length, 1000 by default
        [1]\t output gap array length, 1000 by default
        
        
    params is a list of 6 elements being:
        [0]\t output energy array length
        [1]\t output gap array length
        [2]\t output minimum energy
        [3]\t output maximum energy
        [4]\t output minimum gap
        [5]\t output maximum gap
	
	Use default value for intial test
	
    IOCtable\t EPICS PV for the waveform table number
	
    final\t change to True to write to the waveform table PV

     '''
    data = load_input(file)
    if params is None:
        E0 = np.min(data[0])
        E1 = np.max(data[0])
        G0 = np.min(data[1])
        G1 = np.max(data[1])
        
        output = test_table(data[0],data[1],pts[0],pts[1],E0,E1,G0,G1)
    else:
        output = test_table(data[0],data[1],params[0], params[1],params[2], params[3], params[4], params[5])
    if final is True:
        print('Laoding tables to IOC')
        if __name__ == "__main__":
            print('about to make the table') 
            make_table(output)
        else:
            print('the name space is', __name__)

def fit_input_make_output(xe, yg, Epts = 1000, Emin = None, Emax = None, polydeg = 7, file=None):
    mod = PolynomialModel(polydeg)
    data = np.array([xe,yg])
    pars = mod.guess(yg, x=xe)
    out = mod.fit(yg, pars, x=xe)
    
    if Emin == None:
        Emin = np.min(xe)
    if Emax == None:
        Emax = np.max(xe)
    if file == None:
        file = 'No File'

    xnew = np.linspace(Emin, Emax, Epts)
    ynew = out.eval(x=xnew)
    output = np.array([xnew, ynew])
    
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_title(f'EPU table: {file} nth degree poly = {mod.poly_degree}' )
    ax.set_xlabel('Energy [eV]')
    ax.set_ylabel('Gap [mm]')
    ax.plot(xnew, ynew, 'r-', label = 'fit data for table')
    ax.plot(xe, yg,'bo' , label='measured data')
    ax.plot(xe,out.residual,'g:',label = 'residual')
    ax.grid(True)
    ax.legend()
    print(f'Report from Fit:\[n {out.fit_report(show_correl = False)}')

    return output

def set_EPUioc_table(file, ioc_table_num, write_to_ioc=False, Epts=1000, Emin = None, Emax = None, polydeg = 7 ):
    
    xe, yg = load_input(file)
    
    if Emin == None:
        Emin = np.min(xe)
    if Emax == None:
        Emax = np.max(xe)

    output = fit_input_make_output(xe, yg, Epts, Emin, Emax, polydeg, file)

    print('minimum Energy and Gap:\t', [np.min(x) for x in output])
    print('maximum Energy and Gap:\t', [np.max(x) for x in output])
    
    dE_x, dG_x = [np.round(np.convolve(x, np.ones(2), 'valid') / 2,3) for x in output]  
    dE_y, dG_y = [np.diff(x) for x in output]
    
    fig = plt.figure(figsize=(9,5))
    fig.suptitle('Lookup Table Resolution')
    ax = fig.add_subplot(121)
    #ax.plot(dE_x,dG_y,'.',label = 'foward')
    ax.plot(dG_x,dE_y,'.',label = 'energy')
    ax.set_xlabel('Input Energy [eV]')
    #ax.set_ylabel('Output Gap [mm]')
    ax.set_ylabel('$\Delta$E [eV]')
    ax.legend()
    
    ax = fig.add_subplot(122)
    #ax.plot(dG_x, dE_y, label = 'reverse')
    ax.plot(dG_x, dG_y, label = 'gap')
    ax.set_xlabel('Input Gap [mm]')
    #ax.set_ylabel('Output Energy [eV]')
    ax.set_ylabel('$\Delta$G [mm]')
    ax.legend()

    if write_to_ioc is False:
        print(f'\n\n\t\tJust testing. No data written to IOC for IOC table # {ioc_table_num}')
    else:
        print(f'\n\n\t\tOVER-WRITING PV for IOC table # {ioc_table_num}')
        
        make_table(output, ioc_table_num)
        






 
