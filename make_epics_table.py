#####
# Need input .cvs file with energy, gap.  Will not work with column headers
# Use doc string of set_table() to check/test table before uploading
# Epics table generated by interpolation, but one could add an equation to autogenerate or develop a fit function.
# Upper and lower bounds currently set by input.  Can add another parameter and enable extrapolation for the interpolation function
#
# 09/13/17


import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import csv

def test_table(Emeas,Gmeas,Earraysize, Garraysize,minE, maxE, minG, maxG):
    '''
    This function requires that you hard code your fit to the gap vs energy data.  energy is the x-variable for the forward calculation.
    This function also requires a hard code fit for the reverse interpolation.  gap is the x-varyable.
    '''
    #print(file)
    print('Input energy min and max are:\t', np.min(Emeas),np.max(Emeas))
    print('Input gap min and max are:\t', np.min(Gmeas),np.max(Gmeas))
    
    x = np.linspace(minE, maxE, Earraysize)
    y = np.interp(x, Emeas, Gmeas)
    
    
    
    plt.figure(figsize=(7,7))
    plt.plot(Emeas, Gmeas, 'o', label='input data ')#{}'.format(file))
    plt.plot(x,y,'--r', label='np.interp forward')
    plt.grid(True)
    plt.legend(loc=2)
    plt.show()
    
    x2 = np.linspace(minG, maxG, Garraysize)
    y2 = np.interp(x2, Gmeas, Emeas)

    plt.figure(figsize=(7,7))
    
    plt.plot(Gmeas,Emeas, 'o', label='input data ')#{}'.format(file))
    plt.plot(x2,y2,'--r', label='np.interp reverse')
    plt.grid(True)
    plt.legend(loc=2)
    plt.show()

    return x, y, x2, y2

def make_table(output,IOCtable):
    x=output[0]
    y=output[1]
    x2=output[2]
    y2=output[3]
    
    pv_string = ('XF:02ID-ID{EPU:1-RLT}Val:Table%sa-Wfrm'%(IOCtable))
    print(pv_string)        
    
    #fp = np.concatenate((np.array([x[0], x[1] - x[0], y.size, -1, 1, 3]), y, y, y))
    #pv = epics.PV('XF:02ID-ID{EPU:1-fLT}Val:Table1a-Wfrm')
    #pv.put(fp)
    #print(fp)
    
    #fp = np.concatenate((np.array([x2[0], x2[1] - x2[0], y2.size, -1, 1, 3]), y2, y2, y2))
    #pv = epics.PV('XF:02ID-ID{EPU:1-RLT}Val:Table1a-Wfrm')
    #pv.put(fp)
    #print(fp)

def load_input(file):
    print('Input file is:\t', file,'\n\n')
    with open(file) as csvfile:
        readCSV = csv.reader(csvfile, delimiter='\t')
        xe = []
        yg = []

        for row in readCSV:
            #print(row)  #use just this line to figure out the delimiter  delete csv text in first line if not a number
            en = float(row[1])
            gp = float(row[2])

            xe.append(en)
            yg.append(gp)
        return xe, yg


def set_EPU_table(file,pts = [1000,1000], params = None, IOCtable=1, final=False):
    '''
    pts is the number points for energy, gap:
        [0]/t output energy array length
        [1]/t output gap array length
        
        The script will calculated the number of points required to match fineness used at CSX-2.
	By default the interpolation range is decided by the minimum and maximum of the input data.
        
    params is a list of 6 elements being:
        [0]/t output energy array length
        [1]/t output gap array length
        [2]/t output minimum energy
        [3]/t output maximum energy
        [4]/t output minimum gap
        [5]/t output maximum gap
	
	Use default value for intial test
	
    IOCtable/t EPICS PV for the waveform table number
	
    final/t change to True to write to the waveform table PV

     '''
    data = load_input(file)
    if params is None:
        E0 = np.min(data[0])
        E1 = np.max(data[0])
        G0 = np.min(data[1])
        G1 = np.max(data[1])
        
        output = test_table(data[0],data[1],pts[0],pts[1],E0,E1,G0,G1)
    else:
        output = test_table(data[0],data[1],params[0], params[1],params[2], params[3], params[4], params[5])
    if final is True:
        print('Laoding tables to IOC')
        if __name__ == "__main__":
            
            make_table(output)


